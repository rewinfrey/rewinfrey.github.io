---
layout: default
group: About
title: About
---

{% include line-field-bg.html %}

<section class="landing-section page-card">
  <div class="section-header">
    <h2 class="section-title">About</h2>
  </div>
  <article class="page-article">
    <p>Hello, I'm Rick.</p>

    <p>
      Understanding code — at scale, across languages, and across teams — is one of the hardest problems in software. It's a challenge for humans and AI alike, and I've spent my career building tools that help bridge that gap. I've worked for over a decade in developer tooling, including ten years at <a href="https://github.com">GitHub</a> building large-scale code intelligence platforms. I love designing APIs, CLIs, and user-facing tools, and I care deeply about fast feedback loops, profiling, performance, and the craft of making code more understandable.
    </p>

    <p>
      Most recently at Nuanced, I built <a href="https://github.com/nuanced-dev/lsp">Nuanced LSP</a>, an easy-to-use LSP server multiplexer leveraging a container-based architecture. To interface with Nuanced LSP, I built a TypeScript SDK and CLI, to make it easy to adopt LSP in various AI workflows for humans and agents. I also built Eval-Agent, an evaluation harness to analyze multi-turn agent traces with an emphasis on tool calling and token usage to systematically measure and evaluate an agent's adoption of code intelligence tooling and its impact on task outcomes—focusing on the key metrics of task duration, cost, and tokens. You can read about some of the experiments I designed on Nuanced's blog, <a href="https://www.nuanced.dev/blog/evaluating-lsp">Evaluating the impact of LSP-based code intelligence on coding agents</a>.
    </p>

    <p>
      Prior to Nuanced, I worked at GitHub for 10 years, where I focused on building code intelligence systems supporting code navigation and code search. I contributed heavily to the <a href="https://tree-sitter.github.io/tree-sitter/">Tree-sitter</a> ecosystem of language parsers, helped build an experimental programming language analysis framework named <a href="https://github.com/github/semantic">Semantic</a>, helped build the distributed system powering <a href="https://docs.github.com/en/repositories/working-with-files/using-files/navigating-code-on-github">GitHub code navigation</a> from the ground up, and helped implement a novel approach to name binding resolution named <a href="https://github.com/github/stack-graphs">Stack Graphs</a> which powered <a href="https://github.blog/news-insights/product-news/precise-code-navigation-python-code-navigation-pull-requests/#precise-code-navigation-for-python">GitHub precise code navigation</a>. Along the way, I shipped code navigation to the PR view, contributed to the initial version of GitHub's AI assistant chat service (Copilot Chat), wrote the core prompt building library to manage dynamic prompt contexts for Copilot Chat, and lastly was a core member on GitHub's code-search team and helped build the system named <a href="https://github.blog/engineering/architecture-optimization/the-technology-behind-githubs-new-code-search/">Blackbird</a>. I tried to summarize the experience at GitHub in a blog post, <a href="https://rickwinfrey.com/writings/10-lessons-from-github">10 Lessons from 10 Years at GitHub</a>.
    </p>

    <p>
      My initial passion as an undergraduate student was human languages (Japanese, Mandarin Chinese, and Korean). I translated this love for languages into a love of programming languages.  The majority of my career as a software engineer has been focused on building tools and services to parse and analyze source code across a wide variety of programming languages. More recently I've become interested in the problems with AI code generation within large, complex codebases, and how program analysis techniques can help provide better code intelligence context to help generate more reliable and valuable code while simultaneously reducing token usage.
    </p>

    <p>
      I love to program and enjoy programming in a variety of languages. I've worked at a high level across system languages (Go and Rust), dynamic languages (Ruby, Elixir / Erlang, and some Python), and pure functional languages (Haskell). I have a deep appreciation for the lambda calculus, combinator theory, type theory, and functional programming. I also love the challenges of working on large scale distributed systems, designing and implementing concurrent solutions, profile-guided optimization, and working on extremely large-scale systems (10k+ requests / sec).
    </p>

    <p>
      Outside of work, I'm nearing the completion of a MSc in the <a href="https://www.ox.ac.uk/admissions/graduate/courses/msc-software-engineering">Software Engineering Programme</a> at Oxford University. I expect to complete the program in May 2026. When I'm not studying, I enjoy the planning and precision of woodworking, the physical challenge of surfing, and attempting to make a perfect <a href="https://en.wikipedia.org/wiki/Neapolitan_pizza">Neapolitan pizza</a>. Thanks for visiting.
    </p>
  </article>
</section>
