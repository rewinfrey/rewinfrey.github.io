I"Ã<p>So far this week we‚Äôve looked at the Single Reponsibility Principle, the Open / Closed Principle and the Liskov Substitution Principle. Today we‚Äôll look at the I of SOLID, the Interface Segregation Principle.</p>

<p>Let‚Äôs start with Uncle Bob‚Äôs definition:</p>

<blockquote>
  <p>Clients should not be forced to depend on methods that they do not use.</p>
</blockquote>

<p>When we build interfaces, we want interfaces that have <a href="http://en.wikipedia.org/wiki/Cohesion_(computer_science)">high cohesion</a>. This means that a class or module has a clearly defined single responsibility and contains methods only to achieve that responsibility. When we build interfaces, our interfaces have specific purposes in the context of our application, but sometimes we may make interfaces that are generic enough so that multiple clients speak to that interface. When we make an interface general enough, and multiple clients speak to that interface, then some clients will be exposed to methods of the interface the client doesn‚Äôt need. The trouble here is if a change to one of those other methods in the interface also requires the client to change, then we have required a cascading set of changes throughout our application. This would be a violation of the Interface Substitution Principle.</p>

<p>This principle is easy to understand if we consider how to structure interfaces in such a way, that they maintain high cohesion, while also taking full advantage of the benefits of OOP (encapsulation, inheritance and polymorphism). Let‚Äôs revisit our CheckingAccount and SavingsAccount interface from <a href="http://selfless-singleton.rickwinfrey.com/2012/12/05/building-solid-foundations-of-oop-part-3-lsp/">yesterday‚Äôs post</a> about LSP:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class AccountCalcMonthlyInterestInterface
  attr_accessor :account, :calc_monthly_interest
  def initialize(options)
    self.account               = options[:account]
    self.calc_monthly_interest = CalcMonthlyInterest.new
  end

  def apply_interest
    if account.class == "CheckingAccount"
      calc_monthly_interest.apply_checking_interest(account)
    else
      calc_monthly_interest.apply_savings_interest(account)
    end
  end
end
</code></pre></div></div>

<p>We have an interface with high cohesion, but we‚Äôre not happy with the ‚Äúif‚Äù conditional in <code class="language-plaintext highlighter-rouge">apply_interest</code>. Because checking accounts and savings accounts have different interest rates, our interface has to know something about the account its servicing. Now that our interface is required to know what it‚Äôs speaking with, we have an interface segregation violation.</p>

<p>How can we fix that?</p>

<ol>
  <li>Create an abstract interface for accounts and monthly interest rate.</li>
  <li>Create specific interfaces for checking and savings accounts that inherit from our abstract interface.</li>
  <li>Override the <code class="language-plaintext highlighter-rouge">apply_interest</code> for both checking and savings account interfaces.</li>
</ol>

<p>Let‚Äôs do it:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class AccountCalcMonthlyInterestInterface
  attr_accessor :account, :calc_monthly_interest
  def initialize(options)
    self.account               = options[:account]
    self.calc_monthly_interest = CalcMonthlyInterest.new
  end

  def apply_interest
  end
end

class CheckingInterestInterface &lt; AccountCalcMonthlyInterestInterface
  def apply_interest
    calc_monthly_interest.for_checking(account)
  end
end

class SavingsInterestInterface &lt; AccountCalcMonthlyInterestInterface
  def apply_interest
    calc_monthly_interest.for_savings(account)
  end
end
</code></pre></div></div>

<p>We have segregated our interfaces for checking and savings accounts, so that now, our interfaces have higher cohesion than before, and our clients (checking and savings accounts) are now only exposed to the specific methods they need. We still don‚Äôt feel comfortable with our interfaces just yet though, because there is something about this hard dependency on CalcMonthlyInterest that is troubling. What happens if that class gets changed somehow? Or what if we want to use a different way of calculating interest? Tomorrow, we are going to look at the last of the SOLID principles, the Dependency Inversion Principle, which will give us a way to solve this problem.</p>
:ET