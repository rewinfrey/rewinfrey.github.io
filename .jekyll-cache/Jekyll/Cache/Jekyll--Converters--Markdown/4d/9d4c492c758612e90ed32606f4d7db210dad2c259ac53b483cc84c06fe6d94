I"ß<p><a href="http://en.wikipedia.org/wiki/L_Peter_Deutsch">L Peter Deutsch</a> originally penned the title of this post. I‚Äôve often heard people describe understanding recursion as one of those ‚Äúgot it‚Äù moments, when the universe opened its secret stores of knowledge and gifted the mind of a burgeoning developer with a very powerful tool. For me, recursion has always been hard. Each time I‚Äôm able to peer more into its murky depths, I am humbled to see how little I feel like I really appreciate and understand its power and elegance. I liken it to learning that one can be aware of awareness being aware of awareness.</p>

<p>So in order to help flex that recursive muscle in my brain, I sat down this morning to tackle implementing a recursive <a href="http://en.wikipedia.org/wiki/Minimax#Minimax_algorithm_with_alternate_moves">Minimax</a> algorithm to serve as the AI for an unbeatable Tic Tac Toe game. I spent the previous night reading an older artifical intelligence book a friend gave me, all the wikipedia articles I could find about Minimax, <a href="http://en.wikipedia.org/wiki/Negamax">Negamax</a>, <a href="http://en.wikipedia.org/wiki/Negascout">Negascout</a> and I even ended up reading about <a href="http://en.wikipedia.org/wiki/MTD-f">MTD-f</a>, a variant of the Minimax algorithm family used today for evaluating chess game trees.</p>

<p>But things weren‚Äôt clicking. Several questions were coming to mind as I read over descriptions and psuedocode. After thinking more about where my confusion was stemming from, I realized I didn‚Äôt have a sufficiently clear mental model of how a recursive Minimax solution accounted for intermediate game states. I kept thinking - don‚Äôt I need to associate intermediate game states in the game tree created by the recursive calls somehow? And how in the world do I do that? My mind started dreaming up crazy data structures - my tell-tell sign that I surely had missed something.</p>

<p>As if my mind wanted to taunt me, previous examples of recursion I had seen kept flashing in my head. All of them shared a similar striking feature:  elegance.</p>

<p>One of the first recursive functions I ever learned was calculating the <a href="http://en.wikipedia.org/wiki/Fibonacci_number">Fibonnaci Numbers</a>:</p>

<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">fib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">?</span> <span class="n">n</span> <span class="p">:</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>At one level of thinking, recursion is pretty simple. Unless we want the recursive method to infinitely call itself, we need a way to tell the method to return. This represents our base case. In the above Fibonnaci method, the base case is n &lt; 2. If n &lt; 2, we simply return n, and stop recursively calling fib(n). The base case is always dependent on the context of the problem we‚Äôre solving.</p>

<p>In the case of Minimax applied to Tic Tac Toe, we aren‚Äôt generating a sequence of numbers, but instead a <a href="http://www.ocf.berkeley.edu/~yosenl/extras/alphabeta/alphabeta.html">game tree</a> of possible game states. For my implementation this means creating a separate game tree for each possible next move using a <a href="http://en.wikipedia.org/wiki/Depth-first_search">depth-first search strategy</a>. In this context, my base case is essentially figuring out if any more moves can be made.</p>

<p>So far so good, but I also have to keep track of score so I can determine what move is best to make. Well, determining how to evaluate the board can involve some complicated heuristics, but really all we need is a simple evaluation of the final board state after constructing our game trees. This is when our base case is satisfied: there are no more moves available. If the game results in me winning, that‚Äôs good, so it‚Äôs +1. If it‚Äôs a loss for me, that‚Äôs bad, so that‚Äôs -1. If the game‚Äôs final state is a draw, it‚Äôs not really good or bad, so it‚Äôs 0.</p>

<p>Now I have a score and I‚Äôm ready to return that value. Since we‚Äôve been constructing the game tree recursively by calling our Minimax method again if there are more moves to make, the <a href="http://en.wikipedia.org/wiki/Call_stack">call stack</a> is probably several layers deep by the time we satisfy the base case. For games like Tic Tac Toe that have relatively small game trees, this is probably fine. If we consider a game like chess, however, the number of possible next game states as a function of possible game moves for a given game state is a very very large number. At this time though, we‚Äôre not programming a chess AI, so we can forget that, and figure out how we translate the score into a move.</p>

<p>Since I‚Äôve satisfied the base case, and have returned the score, I want that score to return all the way back through my call stack. Think of it like walking backwards. I made this move, then this move, and so on, until I couldn‚Äôt make any more moves - but the important question is where did I start from? And this is the question that racked my brain for most of the morning, until I spoke with <a href="http://www.ryanverner.com/">Ryan Verner</a>, another 8th Light apprentice. In talking about recursion with him, I was finally able to see what I needed to do in order to walk back through the call stack so I could translate a score into a move. I don‚Äôt want to spoil the fun for someone working on their own Minimax implementation of Tic Tac Toe, so I‚Äôll leave that to the reader to discover.</p>

<p>When I finally saw how to handle the return value and translate it into a move on the board my questions were answered. It was one of those ‚Äúgot it‚Äù moments, but sadly, I did not experience the universe opening up its secret stores of knowledge. Understanding the question of how to handle the return value turned the Minimax into a straightforward problem, rather than a mysterious recursive problem. This also gave me the footing I needed to accomplish another personal goal: explore <a href="http://en.wikipedia.org/wiki/Alpha-beta_pruning">alpha / beta pruning</a> and use it to create a more efficient implementation. Today was great not only for getting a small taste of the divinity of recursion, nor because of alpha and beta values, but mainly because I got to meet the other 8th Light apprentices for the first time, play a 5 0 game of chess with <a href="http://www.8thlight.com/our-team/paul-pagel">Paul Pagel</a>, and also pair with him on an application he‚Äôs working on to help with scheduling. All of this leaves me feeling thankful to be here, and thankful for the very smart people around me.</p>
:ET