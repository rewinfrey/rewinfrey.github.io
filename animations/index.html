---
layout: default
title: Animations
---

<style>
  .animation-section {
    padding: 2rem 0;
  }

  .animation-title {
    font-family: 'Libre Baskerville', Georgia, serif;
    font-size: 1.6rem;
    font-weight: 400;
    color: #3d3a36;
    margin-bottom: 0.5rem;
  }

  .animation-description {
    font-size: 0.95rem;
    color: #8b7355;
    margin-bottom: 2rem;
  }

  .canvas-container {
    width: 100%;
    border-radius: 8px;
    overflow: hidden;
    border: 1px solid rgba(61, 58, 54, 0.15);
    background: #faf9f7;
    margin-bottom: 2rem;
  }

  #pointField {
    display: block;
    width: 100%;
    height: 500px;
  }

  .controls-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    gap: 2rem;
    padding: 2rem;
    background: #fff;
    border-radius: 8px;
    border: 1px solid rgba(61, 58, 54, 0.1);
  }

  .control-group {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .control-label {
    font-family: 'Libre Baskerville', Georgia, serif;
    font-size: 1rem;
    color: #3d3a36;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .control-value {
    font-family: monospace;
    font-size: 0.85rem;
    color: #8b7355;
    background: #faf9f7;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
  }

  .slider-container {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  input[type="range"] {
    flex: 1;
    height: 6px;
    -webkit-appearance: none;
    appearance: none;
    background: linear-gradient(to right, #d4a574, #c45a3b);
    border-radius: 3px;
    outline: none;
  }

  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px;
    height: 18px;
    background: #c45a3b;
    border-radius: 50%;
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    transition: transform 0.15s ease;
  }

  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.1);
  }

  input[type="range"]::-moz-range-thumb {
    width: 18px;
    height: 18px;
    background: #c45a3b;
    border-radius: 50%;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  input[type="color"] {
    width: 50px;
    height: 36px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    padding: 0;
    background: none;
  }

  input[type="color"]::-webkit-color-swatch-wrapper {
    padding: 0;
  }

  input[type="color"]::-webkit-color-swatch {
    border: 2px solid rgba(61, 58, 54, 0.2);
    border-radius: 4px;
  }

  .color-picker-row {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .color-hex {
    font-family: monospace;
    font-size: 0.85rem;
    color: #8b7355;
  }

  /* Compass styles */
  .compass-container {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 1rem;
  }

  .compass {
    width: 120px;
    height: 120px;
    border-radius: 50%;
    background: #faf9f7;
    border: 2px solid rgba(61, 58, 54, 0.2);
    position: relative;
    cursor: pointer;
  }

  .compass-direction {
    position: absolute;
    font-size: 0.7rem;
    font-weight: 600;
    color: #8b7355;
  }

  .compass-n { top: 8px; left: 50%; transform: translateX(-50%); }
  .compass-s { bottom: 8px; left: 50%; transform: translateX(-50%); }
  .compass-e { right: 8px; top: 50%; transform: translateY(-50%); }
  .compass-w { left: 8px; top: 50%; transform: translateY(-50%); }

  .compass-needle {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 4px;
    height: 45px;
    background: linear-gradient(to top, #c45a3b 50%, #3d3a36 50%);
    transform-origin: center bottom;
    transform: translateX(-50%) translateY(-100%);
    border-radius: 2px;
    pointer-events: none;
  }

  .compass-center {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 12px;
    height: 12px;
    background: #c45a3b;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
  }

  .compass-ring {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 80%;
    height: 80%;
    border: 1px dashed rgba(61, 58, 54, 0.15);
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
  }

  @media (max-width: 42em) {
    .controls-panel {
      grid-template-columns: 1fr;
    }

    #pointField {
      height: 350px;
    }
  }
</style>

<section class="animation-section">
  <h1 class="animation-title">Point Field Animation</h1>
  <p class="animation-description">
    A field of points animated like a sheet blowing in the wind. Adjust density to control point spacing,
    wind to control animation intensity, and use the compass to set wind direction.
  </p>

  <div class="canvas-container">
    <canvas id="pointField"></canvas>
  </div>

  <div class="controls-panel">
    <div class="control-group">
      <label class="control-label">
        Density
        <span class="control-value" id="densityValue">50</span>
      </label>
      <div class="slider-container">
        <input type="range" id="density" min="0" max="100" value="50">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        0 = no points, 100 = maximum density
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Wind Speed
        <span class="control-value" id="windValue">5</span>
      </label>
      <div class="slider-container">
        <input type="range" id="wind" min="0" max="10" value="5" step="0.5">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        0 = still, 10 = aggressive wind
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Point Size
        <span class="control-value" id="pointSizeValue">3</span>
      </label>
      <div class="slider-container">
        <input type="range" id="pointSize" min="1" max="10" value="3" step="0.5">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        1 = tiny dots, 10 = large circles
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Jitter
        <span class="control-value" id="jitterValue">0</span>
      </label>
      <div class="slider-container">
        <input type="range" id="jitter" min="0" max="100" value="0">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        0 = uniform waves, 100 = random directions
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Jitter Diameter
        <span class="control-value" id="jitterDiameterValue">5</span>
      </label>
      <div class="slider-container">
        <input type="range" id="jitterDiameter" min="1" max="10" value="5" step="0.5">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        Size of each point's movement circle
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">Point Color</label>
      <div class="color-picker-row">
        <input type="color" id="pointColor" value="#c45a3b">
        <span class="color-hex" id="colorHex">#c45a3b</span>
      </div>
    </div>

    <div class="control-group">
      <label class="control-label">
        Wind Direction
        <span class="control-value" id="directionValue">E</span>
      </label>
      <div class="compass-container">
        <div class="compass" id="compass">
          <div class="compass-ring"></div>
          <span class="compass-direction compass-n">N</span>
          <span class="compass-direction compass-s">S</span>
          <span class="compass-direction compass-e">E</span>
          <span class="compass-direction compass-w">W</span>
          <div class="compass-needle" id="compassNeedle"></div>
          <div class="compass-center"></div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
(function() {
  // Canvas setup
  const canvas = document.getElementById('pointField');
  const ctx = canvas.getContext('2d');

  // Controls
  const densitySlider = document.getElementById('density');
  const windSlider = document.getElementById('wind');
  const pointSizeSlider = document.getElementById('pointSize');
  const jitterSlider = document.getElementById('jitter');
  const jitterDiameterSlider = document.getElementById('jitterDiameter');
  const colorPicker = document.getElementById('pointColor');
  const compass = document.getElementById('compass');
  const compassNeedle = document.getElementById('compassNeedle');

  // Display values
  const densityValue = document.getElementById('densityValue');
  const windValue = document.getElementById('windValue');
  const pointSizeValue = document.getElementById('pointSizeValue');
  const jitterValue = document.getElementById('jitterValue');
  const jitterDiameterValue = document.getElementById('jitterDiameterValue');
  const colorHex = document.getElementById('colorHex');
  const directionValue = document.getElementById('directionValue');

  // Animation state
  let animationId = null;
  let time = 0;
  let startTime = performance.now() / 1000;

  // Parameters
  let params = {
    density: 50,
    wind: 5,
    pointSize: 3,
    jitter: 0,
    jitterDiameter: 5,
    color: '#c45a3b',
    direction: 0  // Radians, 0 = East, PI/2 = South, etc.
  };

  // Simplex noise implementation for smooth, natural movement
  const SimplexNoise = (function() {
    const grad3 = [
      [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
    ];

    const p = [];
    for (let i = 0; i < 256; i++) {
      p[i] = Math.floor(Math.random() * 256);
    }

    const perm = [];
    for (let i = 0; i < 512; i++) {
      perm[i] = p[i & 255];
    }

    function dot(g, x, y) {
      return g[0] * x + g[1] * y;
    }

    return {
      noise2D: function(xin, yin) {
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;

        let n0, n1, n2;
        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;

        let i1, j1;
        if (x0 > y0) { i1 = 1; j1 = 0; }
        else { i1 = 0; j1 = 1; }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;

        const ii = i & 255;
        const jj = j & 255;
        const gi0 = perm[ii + perm[jj]] % 12;
        const gi1 = perm[ii + i1 + perm[jj + j1]] % 12;
        const gi2 = perm[ii + 1 + perm[jj + 1]] % 12;

        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 < 0) n0 = 0;
        else {
          t0 *= t0;
          n0 = t0 * t0 * dot(grad3[gi0], x0, y0);
        }

        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 < 0) n1 = 0;
        else {
          t1 *= t1;
          n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
        }

        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 < 0) n2 = 0;
        else {
          t2 *= t2;
          n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
        }

        return 70 * (n0 + n1 + n2);
      }
    };
  })();

  // Seeded random for consistent per-point random angles
  function seededRandom(x, y, timeBucket) {
    const seed = x * 12.9898 + y * 78.233 + timeBucket * 43.2891;
    const sinSeed = Math.sin(seed) * 43758.5453;
    return sinSeed - Math.floor(sinSeed);
  }

  // Jitter angle refresh period (seconds)
  const JITTER_REFRESH_PERIOD = 3;

  // Get smoothly transitioning random angle for a point
  function getPointRandomAngle(x, y, currentTime) {
    // Calculate which time bucket we're in and progress through it
    const timeBucket = Math.floor(currentTime / JITTER_REFRESH_PERIOD);
    const progress = (currentTime % JITTER_REFRESH_PERIOD) / JITTER_REFRESH_PERIOD;

    // Get angles for current and next time bucket
    const currentAngle = seededRandom(x, y, timeBucket) * Math.PI * 2;
    const nextAngle = seededRandom(x, y, timeBucket + 1) * Math.PI * 2;

    // Smoothly interpolate between angles using eased progress
    // Use smoothstep for natural-feeling transitions
    const easedProgress = progress * progress * (3 - 2 * progress);

    // Handle angle wraparound (take shortest path around the circle)
    let angleDiff = nextAngle - currentAngle;
    if (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
    if (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

    return currentAngle + angleDiff * easedProgress;
  }

  // Resize canvas to match container
  function resizeCanvas() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = canvas.offsetHeight * dpr;
    ctx.scale(dpr, dpr);
  }

  // Calculate grid spacing from density
  function getSpacing() {
    if (params.density === 0) return Infinity;
    // Density 100 = 4px spacing (very dense)
    // Density 1 = 100px spacing (very sparse)
    const minSpacing = 4;
    const maxSpacing = 100;
    return maxSpacing - ((params.density / 100) * (maxSpacing - minSpacing));
  }

  // Get direction name from angle
  function getDirectionName(angle) {
    // Normalize angle to 0-2PI
    const normalized = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    const degrees = normalized * (180 / Math.PI);

    if (degrees >= 337.5 || degrees < 22.5) return 'E';
    if (degrees >= 22.5 && degrees < 67.5) return 'SE';
    if (degrees >= 67.5 && degrees < 112.5) return 'S';
    if (degrees >= 112.5 && degrees < 157.5) return 'SW';
    if (degrees >= 157.5 && degrees < 202.5) return 'W';
    if (degrees >= 202.5 && degrees < 247.5) return 'NW';
    if (degrees >= 247.5 && degrees < 292.5) return 'N';
    if (degrees >= 292.5 && degrees < 337.5) return 'NE';
    return 'E';
  }

  // Main render function
  function render() {
    const width = canvas.offsetWidth;
    const height = canvas.offsetHeight;

    // Clear canvas
    ctx.fillStyle = '#faf9f7';
    ctx.fillRect(0, 0, width, height);

    if (params.density === 0) {
      animationId = requestAnimationFrame(render);
      return;
    }

    const spacing = getSpacing();
    const windSpeed = params.wind;

    // Wind direction components
    const windX = Math.cos(params.direction);
    const windY = Math.sin(params.direction);

    // Time progression based on wind speed
    time += 0.01 * (windSpeed + 0.5);

    // Real elapsed time for jitter angle transitions
    const realTime = performance.now() / 1000 - startTime;

    // Draw points
    for (let x = spacing / 2; x < width; x += spacing) {
      for (let y = spacing / 2; y < height; y += spacing) {
        // Calculate wave influence based on position and wind direction
        const wavePos = (x * windX + y * windY) * 0.01;

        // Multiple layers of noise for natural look
        const noise1 = SimplexNoise.noise2D(x * 0.005 + time * windSpeed * 0.1, y * 0.005 + time * 0.05);
        const noise2 = SimplexNoise.noise2D(x * 0.01 + time * 0.15, y * 0.01 - time * 0.1);
        const noise3 = SimplexNoise.noise2D(x * 0.002 - time * 0.02, y * 0.002 + time * 0.03);

        // Combine noises with wave
        const wave = Math.sin(wavePos + time * windSpeed * 0.5) * 0.5;
        const combined = (noise1 * 0.4 + noise2 * 0.3 + noise3 * 0.3 + wave) * windSpeed * 0.1;

        // Z-displacement affects size and opacity (simulating 3D depth)
        const zDisplacement = combined;
        const size = params.pointSize * (1 + zDisplacement * 0.5);

        // Calculate displacement with jitter
        // jitter=0: move along wind direction, jitter=100: move in random direction
        const jitterAmount = params.jitter / 100;
        const randomAngle = getPointRandomAngle(x, y, realTime);

        // Wind-based direction (current behavior)
        const windDirX = windX;
        const windDirY = windY;

        // Random direction for this point
        const randomDirX = Math.cos(randomAngle);
        const randomDirY = Math.sin(randomAngle);

        // Blend between wind direction and random direction based on jitter
        const blendedDirX = windDirX * (1 - jitterAmount) + randomDirX * jitterAmount;
        const blendedDirY = windDirY * (1 - jitterAmount) + randomDirY * jitterAmount;

        // Apply displacement magnitude (combined from noise) scaled by jitter diameter
        const displacementMagnitude = combined * params.jitterDiameter;
        const xOffset = displacementMagnitude * blendedDirX;
        const yOffset = displacementMagnitude * blendedDirY;

        // Opacity based on z-position (closer = more opaque)
        const opacity = Math.max(0.2, Math.min(1, 0.6 + zDisplacement * 0.4));

        // Parse color and apply opacity
        const hex = params.color;
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);

        ctx.beginPath();
        ctx.arc(x + xOffset, y + yOffset, Math.max(0.5, size), 0, Math.PI * 2);
        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${opacity})`;
        ctx.fill();
      }
    }

    animationId = requestAnimationFrame(render);
  }

  // Compass interaction
  function updateCompassAngle(e) {
    const rect = compass.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    params.direction = angle;

    // Update needle rotation (adjust for CSS transform origin)
    const needleDegrees = angle * (180 / Math.PI) + 90;
    compassNeedle.style.transform = `translateX(-50%) translateY(-100%) rotate(${needleDegrees}deg)`;

    directionValue.textContent = getDirectionName(angle);
  }

  let isDraggingCompass = false;

  compass.addEventListener('mousedown', (e) => {
    isDraggingCompass = true;
    updateCompassAngle(e);
  });

  document.addEventListener('mousemove', (e) => {
    if (isDraggingCompass) {
      updateCompassAngle(e);
    }
  });

  document.addEventListener('mouseup', () => {
    isDraggingCompass = false;
  });

  // Touch support for compass
  compass.addEventListener('touchstart', (e) => {
    isDraggingCompass = true;
    updateCompassAngle(e.touches[0]);
  });

  document.addEventListener('touchmove', (e) => {
    if (isDraggingCompass) {
      updateCompassAngle(e.touches[0]);
    }
  });

  document.addEventListener('touchend', () => {
    isDraggingCompass = false;
  });

  // Control event listeners
  densitySlider.addEventListener('input', (e) => {
    params.density = parseInt(e.target.value);
    densityValue.textContent = params.density;
  });

  windSlider.addEventListener('input', (e) => {
    params.wind = parseFloat(e.target.value);
    windValue.textContent = params.wind;
  });

  pointSizeSlider.addEventListener('input', (e) => {
    params.pointSize = parseFloat(e.target.value);
    pointSizeValue.textContent = params.pointSize;
  });

  jitterSlider.addEventListener('input', (e) => {
    params.jitter = parseInt(e.target.value);
    jitterValue.textContent = params.jitter;
  });

  jitterDiameterSlider.addEventListener('input', (e) => {
    params.jitterDiameter = parseFloat(e.target.value);
    jitterDiameterValue.textContent = params.jitterDiameter;
  });

  colorPicker.addEventListener('input', (e) => {
    params.color = e.target.value;
    colorHex.textContent = e.target.value;
  });

  // Initialize
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  render();
})();
</script>

<!-- Line Field Animation -->
<section class="animation-section" style="margin-top: 4rem; padding-top: 3rem; border-top: 1px solid rgba(61, 58, 54, 0.1);">
  <h1 class="animation-title">Line Field Animation</h1>
  <p class="animation-description">
    A field of lines that fold and ripple like cloth in the wind. Lines wave and overlap
    as the wind passes through, creating organic fabric-like motion.
  </p>

  <div class="canvas-container">
    <canvas id="lineField"></canvas>
  </div>

  <div class="controls-panel">
    <div class="control-group">
      <label class="control-label">
        Line Spacing
        <span class="control-value" id="lineSpacingValue">4</span>
      </label>
      <div class="slider-container">
        <input type="range" id="lineSpacing" min="0" max="50" value="20">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        0 = no separation, 50 = wide spacing
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Line Width
        <span class="control-value" id="lineWidthValue">0.5</span>
      </label>
      <div class="slider-container">
        <input type="range" id="lineWidth" min="0.5" max="8" value="2" step="0.5">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        Thickness of each line
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Wind Speed
        <span class="control-value" id="lineWindValue">2.5</span>
      </label>
      <div class="slider-container">
        <input type="range" id="lineWind" min="0" max="10" value="5" step="0.5">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        0 = still, 10 = aggressive wind
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Wind Size
        <span class="control-value" id="lineWindSizeValue">70</span>
      </label>
      <div class="slider-container">
        <input type="range" id="lineWindSize" min="1" max="100" value="50">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        1 = small gusts, 100 = broad waves
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Line Jitter
        <span class="control-value" id="lineJitterValue">15</span>
      </label>
      <div class="slider-container">
        <input type="range" id="lineJitter" min="0" max="100" value="50">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        Ripple/fold intensity between lines
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">
        Line Jitter Diameter
        <span class="control-value" id="lineJitterDiameterValue">50</span>
      </label>
      <div class="slider-container">
        <input type="range" id="lineJitterDiameter" min="5" max="60" value="30">
      </div>
      <p style="font-size: 0.8rem; color: #8b7355; margin: 0;">
        How much lines can overlap
      </p>
    </div>

    <div class="control-group">
      <label class="control-label">Line Color</label>
      <div class="color-picker-row">
        <input type="color" id="lineColor" value="#80776b">
        <span class="color-hex" id="lineColorHex">#80776b</span>
      </div>
    </div>

    <div class="control-group">
      <label class="control-label">
        Wind Direction
        <span class="control-value" id="lineWindDirectionValue">E</span>
      </label>
      <div class="compass-container">
        <div class="compass" id="lineWindCompass">
          <div class="compass-ring"></div>
          <span class="compass-direction compass-n">N</span>
          <span class="compass-direction compass-s">S</span>
          <span class="compass-direction compass-e">E</span>
          <span class="compass-direction compass-w">W</span>
          <div class="compass-needle" id="lineWindCompassNeedle"></div>
          <div class="compass-center"></div>
        </div>
      </div>
    </div>

    <div class="control-group">
      <label class="control-label">
        Line Orientation
        <span class="control-value" id="lineOrientationValue">N-S</span>
      </label>
      <div class="compass-container">
        <div class="compass" id="lineOrientationCompass">
          <div class="compass-ring"></div>
          <span class="compass-direction compass-n">N</span>
          <span class="compass-direction compass-s">S</span>
          <span class="compass-direction compass-e">E</span>
          <span class="compass-direction compass-w">W</span>
          <div class="compass-needle" id="lineOrientationCompassNeedle" style="transform: translateX(-50%) translateY(-100%) rotate(0deg);"></div>
          <div class="compass-center"></div>
        </div>
      </div>
    </div>
  </div>
</section>

<script>
(function() {
  // Canvas setup
  const canvas = document.getElementById('lineField');
  const ctx = canvas.getContext('2d');

  // Controls
  const lineSpacingSlider = document.getElementById('lineSpacing');
  const lineWidthSlider = document.getElementById('lineWidth');
  const lineWindSlider = document.getElementById('lineWind');
  const lineWindSizeSlider = document.getElementById('lineWindSize');
  const lineJitterSlider = document.getElementById('lineJitter');
  const lineJitterDiameterSlider = document.getElementById('lineJitterDiameter');
  const lineColorPicker = document.getElementById('lineColor');
  const lineWindCompass = document.getElementById('lineWindCompass');
  const lineWindCompassNeedle = document.getElementById('lineWindCompassNeedle');
  const lineOrientationCompass = document.getElementById('lineOrientationCompass');
  const lineOrientationCompassNeedle = document.getElementById('lineOrientationCompassNeedle');

  // Display values
  const lineSpacingValue = document.getElementById('lineSpacingValue');
  const lineWidthValue = document.getElementById('lineWidthValue');
  const lineWindValue = document.getElementById('lineWindValue');
  const lineWindSizeValue = document.getElementById('lineWindSizeValue');
  const lineJitterValue = document.getElementById('lineJitterValue');
  const lineJitterDiameterValue = document.getElementById('lineJitterDiameterValue');
  const lineColorHex = document.getElementById('lineColorHex');
  const lineWindDirectionValue = document.getElementById('lineWindDirectionValue');
  const lineOrientationValue = document.getElementById('lineOrientationValue');

  // Animation state
  let animationId = null;
  let time = 0;

  // Parameters
  let params = {
    spacing: 4,
    width: 0.5,
    wind: 2.5,
    windSize: 75,
    jitter: 15,
    jitterDiameter: 60,
    color: '#80776b',
    windDirection: 0,        // Direction wind blows (affects wave propagation)
    lineOrientation: -Math.PI / 2  // Direction lines run (-PI/2 = vertical/N-S)
  };

  // Simplex noise implementation
  const SimplexNoise = (function() {
    const grad3 = [
      [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
      [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
      [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
    ];

    const p = [];
    for (let i = 0; i < 256; i++) {
      p[i] = Math.floor(Math.random() * 256);
    }

    const perm = [];
    for (let i = 0; i < 512; i++) {
      perm[i] = p[i & 255];
    }

    function dot(g, x, y) {
      return g[0] * x + g[1] * y;
    }

    return {
      noise2D: function(xin, yin) {
        const F2 = 0.5 * (Math.sqrt(3) - 1);
        const G2 = (3 - Math.sqrt(3)) / 6;

        let n0, n1, n2;
        const s = (xin + yin) * F2;
        const i = Math.floor(xin + s);
        const j = Math.floor(yin + s);
        const t = (i + j) * G2;
        const X0 = i - t;
        const Y0 = j - t;
        const x0 = xin - X0;
        const y0 = yin - Y0;

        let i1, j1;
        if (x0 > y0) { i1 = 1; j1 = 0; }
        else { i1 = 0; j1 = 1; }

        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;

        const ii = i & 255;
        const jj = j & 255;
        const gi0 = perm[ii + perm[jj]] % 12;
        const gi1 = perm[ii + i1 + perm[jj + j1]] % 12;
        const gi2 = perm[ii + 1 + perm[jj + 1]] % 12;

        let t0 = 0.5 - x0 * x0 - y0 * y0;
        if (t0 < 0) n0 = 0;
        else {
          t0 *= t0;
          n0 = t0 * t0 * dot(grad3[gi0], x0, y0);
        }

        let t1 = 0.5 - x1 * x1 - y1 * y1;
        if (t1 < 0) n1 = 0;
        else {
          t1 *= t1;
          n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
        }

        let t2 = 0.5 - x2 * x2 - y2 * y2;
        if (t2 < 0) n2 = 0;
        else {
          t2 *= t2;
          n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
        }

        return 70 * (n0 + n1 + n2);
      }
    };
  })();

  // Get consistent phase offset for a line based on its index
  function getLinePhaseOffset(lineIndex) {
    const seed = lineIndex * 127.1 + 311.7;
    const sinSeed = Math.sin(seed) * 43758.5453;
    const random = sinSeed - Math.floor(sinSeed);
    return random * Math.PI * 2;
  }

  // Resize canvas
  function resizeCanvas() {
    const rect = canvas.parentElement.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = canvas.offsetHeight * dpr;
    ctx.scale(dpr, dpr);
  }

  // Get direction name
  function getDirectionName(angle) {
    const normalized = ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    const degrees = normalized * (180 / Math.PI);

    if (degrees >= 337.5 || degrees < 22.5) return 'E';
    if (degrees >= 22.5 && degrees < 67.5) return 'SE';
    if (degrees >= 67.5 && degrees < 112.5) return 'S';
    if (degrees >= 112.5 && degrees < 157.5) return 'SW';
    if (degrees >= 157.5 && degrees < 202.5) return 'W';
    if (degrees >= 202.5 && degrees < 247.5) return 'NW';
    if (degrees >= 247.5 && degrees < 292.5) return 'N';
    if (degrees >= 292.5 && degrees < 337.5) return 'NE';
    return 'E';
  }

  // Main render function
  function render() {
    const width = canvas.offsetWidth;
    const height = canvas.offsetHeight;

    // Clear canvas
    ctx.fillStyle = '#faf9f7';
    ctx.fillRect(0, 0, width, height);

    const windSpeed = params.wind;
    const spacing = Math.max(1, params.spacing); // Minimum 1px to prevent infinite lines
    const jitterAmount = params.jitter / 100;
    const jitterDiameter = params.jitterDiameter;

    // Wind direction (affects wave propagation)
    const windAngle = params.windDirection;
    const windX = Math.cos(windAngle);
    const windY = Math.sin(windAngle);

    // Line orientation (independent from wind)
    const lineAngle = params.lineOrientation;
    const lineX = Math.cos(lineAngle);  // Direction lines run
    const lineY = Math.sin(lineAngle);
    const perpX = Math.cos(lineAngle + Math.PI / 2);  // Perpendicular to lines (for spacing)
    const perpY = Math.sin(lineAngle + Math.PI / 2);

    // Time progression
    time += 0.01 * (windSpeed + 0.5);

    // Calculate how many lines we need and the range to cover
    const diagonal = Math.sqrt(width * width + height * height);
    const numLines = Math.ceil(diagonal / spacing) + 4;
    const startOffset = -diagonal / 2;

    // Parse color
    const hex = params.color;
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);

    // Center of canvas
    const centerX = width / 2;
    const centerY = height / 2;

    // Draw lines from back to front for proper layering
    for (let i = 0; i < numLines; i++) {
      const lineOffset = startOffset + i * spacing;

      // Base position of this line (offset from center perpendicular to line direction)
      const baseX = centerX + perpX * lineOffset;
      const baseY = centerY + perpY * lineOffset;

      // Get per-line phase offset for jitter
      const linePhase = getLinePhaseOffset(i);

      // Calculate points along this line
      const points = [];
      const segmentLength = 4; // Resolution of line segments
      const lineLength = diagonal * 1.5;
      const numSegments = Math.ceil(lineLength / segmentLength);

      for (let j = 0; j <= numSegments; j++) {
        const t = (j / numSegments - 0.5) * lineLength;

        // Position along the line direction
        const px = baseX + lineX * t;
        const py = baseY + lineY * t;

        // Calculate wave displacement
        // Wind size affects noise scale: larger windSize = smaller scale = broader patterns
        // Scale factor: windSize 1 = 0.02 (small), windSize 100 = 0.001 (very broad)
        const sizeScale = 0.001 + (0.02 - 0.001) * (1 - params.windSize / 100);
        const noiseScale1 = sizeScale;
        const noiseScale2 = sizeScale * 1.8;
        const noiseScale3 = sizeScale * 0.4;

        const noise1 = SimplexNoise.noise2D(
          px * noiseScale1 + time * windSpeed * 0.1,
          py * noiseScale1 + time * 0.05
        );
        const noise2 = SimplexNoise.noise2D(
          px * noiseScale2 + time * 0.12,
          py * noiseScale2 - time * 0.08
        );
        const noise3 = SimplexNoise.noise2D(
          px * noiseScale3 - time * 0.03,
          py * noiseScale3 + time * 0.02
        );

        // Wave based on position along wind direction
        // Also scale wave frequency with wind size
        const waveScale = 0.005 + (0.03 - 0.005) * (1 - params.windSize / 100);
        const wavePos = (px * windX + py * windY) * waveScale;
        const wave = Math.sin(wavePos + time * windSpeed * 0.3 + linePhase * jitterAmount);

        // Combine noise and wave
        // jitter controls how much the per-line phase affects the wave
        const baseDisplacement = (noise1 * 0.4 + noise2 * 0.35 + noise3 * 0.25);
        const waveComponent = wave * 0.5 * jitterAmount;
        const combined = (baseDisplacement + waveComponent) * windSpeed * 0.15;

        // Displacement magnitude scales with jitter diameter
        const displacement = combined * jitterDiameter;

        // Displace point perpendicular to line direction (creates fold effect)
        const finalX = px + perpX * displacement;
        const finalY = py + perpY * displacement;

        points.push({ x: finalX, y: finalY });
      }

      // Draw the line as a single continuous path
      if (points.length > 1) {
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let j = 1; j < points.length; j++) {
          ctx.lineTo(points[j].x, points[j].y);
        }
        ctx.lineWidth = params.width;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
        ctx.stroke();
      }
    }

    animationId = requestAnimationFrame(render);
  }

  // Get orientation label (shows axis like N-S, E-W, etc.)
  function getOrientationName(angle) {
    const normalized = ((angle % Math.PI) + Math.PI) % Math.PI;
    const degrees = normalized * (180 / Math.PI);

    if (degrees < 22.5 || degrees >= 157.5) return 'E-W';
    if (degrees >= 22.5 && degrees < 67.5) return 'NE-SW';
    if (degrees >= 67.5 && degrees < 112.5) return 'N-S';
    if (degrees >= 112.5 && degrees < 157.5) return 'NW-SE';
    return 'E-W';
  }

  // Wind compass interaction
  function updateWindCompassAngle(e) {
    const rect = lineWindCompass.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    params.windDirection = angle;

    const needleDegrees = angle * (180 / Math.PI) + 90;
    lineWindCompassNeedle.style.transform = `translateX(-50%) translateY(-100%) rotate(${needleDegrees}deg)`;

    lineWindDirectionValue.textContent = getDirectionName(angle);
  }

  // Line orientation compass interaction
  function updateOrientationCompassAngle(e) {
    const rect = lineOrientationCompass.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;

    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    params.lineOrientation = angle;

    const needleDegrees = angle * (180 / Math.PI) + 90;
    lineOrientationCompassNeedle.style.transform = `translateX(-50%) translateY(-100%) rotate(${needleDegrees}deg)`;

    lineOrientationValue.textContent = getOrientationName(angle);
  }

  let isDraggingWindCompass = false;
  let isDraggingOrientationCompass = false;

  lineWindCompass.addEventListener('mousedown', (e) => {
    isDraggingWindCompass = true;
    updateWindCompassAngle(e);
  });

  lineOrientationCompass.addEventListener('mousedown', (e) => {
    isDraggingOrientationCompass = true;
    updateOrientationCompassAngle(e);
  });

  document.addEventListener('mousemove', (e) => {
    if (isDraggingWindCompass) {
      updateWindCompassAngle(e);
    }
    if (isDraggingOrientationCompass) {
      updateOrientationCompassAngle(e);
    }
  });

  document.addEventListener('mouseup', () => {
    isDraggingWindCompass = false;
    isDraggingOrientationCompass = false;
  });

  lineWindCompass.addEventListener('touchstart', (e) => {
    isDraggingWindCompass = true;
    updateWindCompassAngle(e.touches[0]);
  });

  lineOrientationCompass.addEventListener('touchstart', (e) => {
    isDraggingOrientationCompass = true;
    updateOrientationCompassAngle(e.touches[0]);
  });

  document.addEventListener('touchmove', (e) => {
    if (isDraggingWindCompass) {
      updateWindCompassAngle(e.touches[0]);
    }
    if (isDraggingOrientationCompass) {
      updateOrientationCompassAngle(e.touches[0]);
    }
  });

  document.addEventListener('touchend', () => {
    isDraggingWindCompass = false;
    isDraggingOrientationCompass = false;
  });

  // Control event listeners
  lineSpacingSlider.addEventListener('input', (e) => {
    params.spacing = parseInt(e.target.value);
    lineSpacingValue.textContent = params.spacing;
  });

  lineWidthSlider.addEventListener('input', (e) => {
    params.width = parseFloat(e.target.value);
    lineWidthValue.textContent = params.width;
  });

  lineWindSlider.addEventListener('input', (e) => {
    params.wind = parseFloat(e.target.value);
    lineWindValue.textContent = params.wind;
  });

  lineWindSizeSlider.addEventListener('input', (e) => {
    params.windSize = parseInt(e.target.value);
    lineWindSizeValue.textContent = params.windSize;
  });

  lineJitterSlider.addEventListener('input', (e) => {
    params.jitter = parseInt(e.target.value);
    lineJitterValue.textContent = params.jitter;
  });

  lineJitterDiameterSlider.addEventListener('input', (e) => {
    params.jitterDiameter = parseInt(e.target.value);
    lineJitterDiameterValue.textContent = params.jitterDiameter;
  });

  lineColorPicker.addEventListener('input', (e) => {
    params.color = e.target.value;
    lineColorHex.textContent = e.target.value;
  });

  // Initialize
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();
  render();
})();
</script>
